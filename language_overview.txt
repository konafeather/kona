This is a quick overview of the Kona programming language.


---- Comments

Comments are lines of code that are ignored by the compiler. They provide helpful hints for other programmers who are reading an author's code. This is a single line comment:

# a sentence describing code

This is a multi-line comment:

#[ I am a
   multi-line
   comment
]#


---- Assignment

Declaring and reassigning variables in Kona are explicit. This is how to declare an immutable variable:

val a = 1

Declare a mutable variable (the type is inferred):

mut b = 10

Reassign to a mutable variable:

let b = 11

Although Kona is a statically typed language, types are not declared before the assignment operator. Instead, types are inferred from the value on the right hand side. If the user wants a different type than what can be inferred, simply cast the value to the correct type. In this example, the integer is cast to a float by writing the type inside of "|...|".

mut c = |Flt| 100

An undefined variable infers the type based on how it is used in the future:

# "y" is an integer
mut y

let y = 2


---- Types

Here are all the types Kona will support:

Integers: Int, I8, I16, I32, I64, I128

Unsigned Integers:  UInt, U8, U16, U32, U64, U128

Floating Point Integers: Flt, F16, F32, F64, F128

Booleans: Bool

Strings: Str

Arrays: [Int], [Str], etc...

Anonymous Object: {Str -> Int}, etc...

Class: Example

Template: Example


---- Arithmetic Operators

+, -, *, /, %


---- Comparison Operators

==, !=, <, >, <=, >=


---- Print Line

To print text to standard output, call the built-in function "echo". This will automatically add a new line afer the line of input:

echo "Hello world!"
echo "More text!"

# output -> Hello world!
#           More text!

Additionally, "echoln" adds the output to the same line as the previous output. 

echoln: "Hello world!"
echoln: " More text!"

# output -> Hello world! More text!


---- Strings

# "~" is for string concatenation. It doesn't just join strings, but also converts its operands to strings. """ is a multi-line string literal.

echoln: "what" ~ hello ~ is ~ "hello"

final greeting = "The weather:" ~
"45 degrees" ~
"sunny" ~
"I want to go to the beach"

final greeting = """
The weather:
45 degrees
sunny
I want to go to the beach!
"""


---- If, Else If, Else

A typical if/then series of blocks:

val a = 1

if a == 3
   echo "not true"

elif a > 3
   echo "still not true"

else
   echo "less than 3"


---- Switch Statement

A typical switch statement. "is ..." saves the programmer from an extra level of indentation.

val x = 1

when x is 1

   echo: "match"

is 2

   let x = 2

otherwise

   echo: "default"


---- Loops

# "|" are lines in a block that would appear in an IDE, not actual characters to be typed.

while 3 > 4

    echo "block not executed"

val fruits = ["apple", "banana", "orange", "strawberry"]

for item, index in fruits

   while item != "strawberry"
   |
   |  echo "fruit number: " ~ index

# can have break, continue, redo


--- Do-While Loop

val x = 1

do
   x++

while x < 100


---- Functions

The types of parameters are inferred by the type of argument in the function call. Each inferred type must be the same among all function calls. The return type of the function is also inferred. Any value after "return ..." must be of the same type. Functions can return multiple values, like in Golang. If the user wants to return a type that can't be inferred, then they must make a cast in the return statement:

fun countDown: begin, max
   
    for number in reverse: begin..max
    |
    |  echo: number
		
    return max

# Function calls with arguments use a colon, while function calls without arguments end with a semicolon:
countDown: 1, 25
randomFunc;

# error: incorrect argument type
countDown: 1.15, 25

# if the function needs to be nested inside another function or array, it can be wrapped in parenthesis
val arr = [1, (countDown: 1, 25), 75]

# built-in functions like "echo ..." don't use colons


---- Generic Functions

Generic parameters are represented by "'..." and occur after the parameter name:


# the return type is inferred to be a string
# in 'C 'A, 'A is the generic return type
fun message: a 'A, b 'B, c 'C 'A
   if a == b
   |  return a ~ b
   |
   elif a == c
   |  return a ~ b ~ c
   |
   else
   |  return toStr: a

echo: message: "one", 2, 3             # function calls can be nested with colon syntax
echo: message: "one", 2, "three"


---- if/then and function one-liner

if x == 4 then echo x

fun add: left, right then return left + right


---- Arrays

val items = [1, 2, 3, true, "hello"]
val slice = items[1..3]

items.push: 8
items.append: arr
items.splice: start -> 4, remove -> 2, [2, 3, 4]
items[5].pull;


---- Anonymous Object

# anonymous objects are not represented by classes.

val anon_object = {
   one -> 1, 
   two -> [1, 2], 
   three -> {
      four -> 4
   }

   # can include methods too
   fun add: left, right
      echo left + right
}

# accessing a property
anon_object.three.four

# accessing a method
anon_object.add: 8, 8


---- Error Handling

Errors are caught with a simple "try ... catch err" statement. Errors can also be caught as values by declaring a variable after the catch keyword. If no error is caught, the error value is null:

try
   # some error prone operations
   list_files: "home/downloads"
   list_files: "home/documents"

catch val err_value
   when err_name is PathError
   ...
   is EOF
   ...
   otherwise
   ...
finally
   ...


echo err_value


---- Classes

The "mut" keyword before a class allows the class to be extended. Properties are public and immutable by default. They can be made mutable with "mut" and private with "priv". The types of properties are inferred just like parameter types. The "mut" keyword before a method allows the method to be overrided by an extended class. Interfaces enforce that the same group of method signatures are present in every class with that interface. All classes with the same interface are of the same type. The type would be the name of the interface:

mut class Car extends Automobile
                                    
   wheel,
   priv mut axle,
   extension,
   mut mirror

   interface Move
   |  priv fun drive: one, two
   |  |  val number = one
   |  |  return wheel + mirror
   |
   |  fun velocity: speed
   |  |  return speed * 4

   mut fun manipulate: tread
   |  self.mirror = true
   |  velocity: tread * 3.14


# initialize the object
val jetta = Car {
   wheel -> "expensive",
   axle -> "strong",
   extension -> Car {
      ...
   },
   mirror -> false
}


---- Templates

Templates are like interfaces, but they can define common properties of classes too. They are similar to protocols in swift. Template properties require that the class that implements the template includes the same property names as the template properties, and a common property type. The "def" keyword before a property inserts a default property into the class of the template. Template methods are method signatures that enforce that the method of that signature is present in the class. A "def" keyword before a method inserts a default method signature and body into the class of the template. Templates can extend other templates:

template Saturn ext AnotherTemplate
   def axle
   wheel,
   tire,
   orange

   fun add: apple, banana, strawberry

   fun sub: red, blue, green
   
   # like an optional method/mixin
   def fun mult: left, right
      return left * right


---- Enums

Enums define variants of a user-defined data type. An anonymous object can be attached to each variant. Each attached anonymous object can conform to a template.

enum Weekday of Data

   MONDAY {
      one -> 1,
      two -> 2
      fun signal then return |Weekday| TUESDAY
   }

   TUESDAY {
      one -> 2,
      two -> 3
      fun signal then return |Weekday| MONDAY
   }

template Data
   def one Int,
   def two Int
   fun signal;

val day = Weekday >> MONDAY

when day is monday
   ...
is tuesday
   ...


day[1]    # MONDAY


---- Summary

And that covers the basics of the language! I hope to include async/await, channels, and the ability to pause/resume the execution of tasks. If you would like to help out, consider becoming a contributor.

